XML Parser Class
================

.. contents::
	:local:
	:depth: 1

Calling the XML Parser Class
----------------------------

ExpressionEngine has an abstracted XML parser that enables developers to
work with XML information more easily than with PHP's built-in XML
functions.

To use the XML parser in your modules, you need to first instantiate the
XML Parser Class

::

    ee()->load->library('xmlparser');

Parsing XML
-----------

Description
~~~~~~~~~~~

obj **ee()->xmlparser->parse\_xml** ( string xml )

This function returns an abstracted object containing all of the tags,
attributes, and values from the XML. The string parameter must be valid
and well-formed XML. Below is an example of the structures generated by
this function.

Sample XML
~~~~~~~~~~

::

    $simple = "<emails>
                <email>
                    <from>Samantha</from>
                    <to>Gertrude</to>
                    <subject>You coming to the party?</subject>
                    <message type='urgent'>It starts at 9pm.  Don't forget to bring the gruyère!</message>
                </email>
            </emails>";

Using ee()->xmlparser->parse\_xml()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    $xml_obj = ee()->xmlparser->parse_xml($simple);

Structure of ee()->xmlparser->parse\_xml()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    xml_cache Object
    (
        [tag] => emails
        [attributes] =>
        [value] =>
        [children] => Array
            (
                [0] => xml_cache Object
                    (
                        [tag] => email
                        [attributes] =>
                        [value] =>
                        [children] => Array
                            (
                                [0] => xml_cache Object
                                    (
                                        [tag] => from
                                        [attributes] =>
                                        [value] => Samantha
                                        [children] =>
                                    )

                                [1] => xml_cache Object
                                    (
                                        [tag] => to
                                        [attributes] =>
                                        [value] => Gertrude
                                        [children] =>
                                    )

                                [2] => xml_cache Object
                                    (
                                        [tag] => subject
                                        [attributes] =>
                                        [value] => You coming to the party?
                                        [children] =>
                                    )

                                [3] => xml_cache Object
                                    (
                                        [tag] => message
                                        [attributes] => Array
                                            (
                                                [type] => urgent
                                            )

                                        [value] => It starts at 9pm.  Don't forget to bring the gruyère!
                                        [children] =>
                                    )

                            )

                    )

            )

    )

With this structure, each tag as an array of objects for each child. In
addition to the **children** array, there are three other variables for
each tag object.

tag
~~~

The tag's name.

attributes
~~~~~~~~~~

If present, they are stored as an array of $key => $val pairs.

value
~~~~~

The contents of the tag.

Converting Delimited Text to XML
--------------------------------

The XML Parser class includes a function to help you create XML from
delimited data.

Description
~~~~~~~~~~~

string **ee()->xmlparser->delimited\_to\_xml** ( array parameters )

Takes delimited data and returns XML. Returns FALSE if unable to create
XML, and uses the XML class $errors array to log errors encountered. You
should always check the $errors array before using the returned XML.

Parameters
~~~~~~~~~~

This method takes an array of parameters, using the following keys:

data
~~~~

(string) delimited text data (comma-delimited, tab-delimited,
quote-enclosed, etc.)

structure
~~~~~~~~~

(array) structure of the delimited data.

root
~~~~

(string) The root XML document tag name. Default is **'root'**

element
~~~~~~~

(string) The name of the primary element that will be used to
enclose each record / row of data. Default is **'element'**

delimiter
~~~~~~~~~

(string) The character delimiting the text. The default is **\\t**
(tab).

enclosure
~~~~~~~~~

(string) Character used to enclose the data, such as **"** in the
case of $data = '"item1", "item2", "item3"'; Default is none (empty
string)

Sample data
~~~~~~~~~~~

::

    $data = "Samantha|Gertrude|You coming to the party?|It starts at 9pm.  Don't forget to bring the gruyère!
    Inigo|Westley|I know something you don't know.|I am not left-handed!";

    $structure = array("from", "to", "subject", "message");

    $delimiter = "|";

    $root = "emails";

    $element = "email";

Using ee()->xmlparser->delimited\_to\_xml()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    $params = array(
            'data'      => $data,
            'structure' => $structure,
            'delimiter' => $delimiter,
            'root'      => $root,
            'element'   => $element
            );

    $xml = ee()->xmlparser->delimited_to_xml($params);

Result
~~~~~~

::

    <emails>
        <email>
            <from>Samantha</from>
            <to>Gertrude</to>
            <subject>You coming to the party?</subject>
            <message>It starts at 9pm.  Don't forget to bring the gruyère!</message>
        </email>
        <email>
            <from>Inigo</from>
            <to>Westley</to>
            <subject>I know something you don't know.</subject>
            <message>I am not left-handed!</message>
        </email>
    </emails>

Checking for Errors
~~~~~~~~~~~~~~~~~~~

You should always check for the presence of errors before using the
returned XML. This will allow you to tell which records were skipped and
unable to be used in the XML. ee()->xmlparser->delimited\_to\_xml()
will only return FALSE on fatal errors, as in some cases it may be
acceptable to ignore the errors.

Errors are logged in the ee()->xmlparser->errors array. Below is an
example of how you might use them.

::

    if ( ! empty(ee()->xmlparser->errors))
    {
        echo "Could not convert to XML:<br /><br />";

        foreach (ee()->xmlparser->errors as $error)
        {
            echo "{$error}<br />";
            exit;
        }
    }

You can also take advantage of the show\_user\_error() method from the
Output class to generate an ExpressionEngine style error page:

::

    if ( ! empty(ee()->xmlparser->errors))
    {
        ee()->output->show_user_error('general', ee()->xmlparser->errors);
        exit;
    }

